---
title: "Taxonomy"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

```{r}
library("tidyr")
library(readr)
library(dplyr)
library(ggplot2)
library(viridis)
library(ggthemes)
```


# Import Data

## import taxonomy data
```{r}
raw_tax_clusters <- read_csv("~/Desktop/erie_story_r_work/genome_by_genome_overview_updated.csv")
```

```{r}
table(raw_tax_clusters$`VC Status`)

head(raw_tax_clusters[grep("--", raw_tax_clusters$Genome),])
```

need to parse the Genome line to be able to match with the contig column in the "merged_3kb...clusters_parsed" file
```{r}
raw_tax_clusters$Genome <- sub(".*_3000_viralonly_", "", raw_tax_clusters$Genome)
```

```{r}
head(raw_tax_clusters[grep("--", raw_tax_clusters$Genome),])
```



number of unique taxonomy clusters
```{r}
length(unique(raw_tax_clusters$`VC`))
```

sort the file based on VC --FROM VCONTACT2 OLD TAXONOMY   
```{r}
#tax_assigned_clusters <- separate(raw_tax_clusters, `VC Status`, into=c("VC_status", "overlaps"), sep=" ", remove = F)
```

```{r}
VPs <- read_tsv("~/Desktop/erie_story_r_work/merged_3kb_trimmed_viruses_and_ma_virus_references_95-85_clusters_parsed.tsv", col_names=T)

colnames(VPs)[1] <- "VP_ID"
```

```{r}
head(VPs)
write_tsv(VPs, "VPs.tsv",col_names = T)
```

```{r}
table(VPs$contig %in% raw_tax_clusters$Genome)

table(VPs$contig %in% raw_tax_clusters$Genome)

table(raw_tax_clusters$Genome[!grepl("~", raw_tax_clusters$Genome)] %in% VPs$contig)
```

```{r}
table(grepl("--", raw_tax_clusters$Genome))
table(grepl("lcl", raw_tax_clusters$Genome))
table(grepl("~", raw_tax_clusters$Genome))
```


```{r}
table(grepl("--", VPs$contig))
table(grepl("lcl", VPs$contig))
```

found reason for mismatch between VPs and vcontact output here...ALL UNDER 3kB!!!
```{r}
VPs[!grepl("lcl", VPs$contig) & !(VPs$contig %in% raw_tax_clusters$Genome),]
```


```{r}
tax_assigned_clusters <- raw_tax_clusters %>% 
  left_join(VPs, by=c("Genome"="contig"))
```

```{r}
tail(tax_assigned_clusters)
```

are there VPs across vcontact clusters?

```{r}
tax_assigned_clusters$VC_subcluster_VP_combo <- paste(tax_assigned_clusters$`VC`,
                                                      tax_assigned_clusters$VP_ID,
                                                      sep="--")
```

```{r}
head(tax_assigned_clusters)
```


```{r}
length(unique(tax_assigned_clusters$VC_subcluster_VP_combo[grepl("--", tax_assigned_clusters$Genome) ]))
length(unique(tax_assigned_clusters$`VC`[grepl("--", tax_assigned_clusters$Genome) ]))
length(unique(tax_assigned_clusters$VP_ID[grepl("--", tax_assigned_clusters$Genome) ]))
```


these numbers are still by contig (NOT VP!)
```{r}
table(tax_assigned_clusters$`VC Status`[grepl("--", tax_assigned_clusters$Genome) ])

table(tax_assigned_clusters$`VC Status`[grep("--", tax_assigned_clusters$Genome)])
length(unique(tax_assigned_clusters$unique_vc_subcluster[grep("--", tax_assigned_clusters$Genome)]))
table(tax_assigned_clusters$`VC Status`)
```

```{r}
vc_status <- separate(tax_assigned_clusters, `VC Status`, into=c("VC Status", "overlaps"), sep=" ", remove = F)
vc_status <- reshape::melt(table(vc_status$`VC Status`[grep("--", vc_status$Genome)]))
colnames(vc_status) <- c("Status", "Count")
vc_status$binary <- "Not Clustered"
vc_status$binary[vc_status$Status=="Clustered"] <- "Clustered"
```

```{r}
vc_status_pops <- separate(tax_assigned_clusters_my_VPs, `VC Status`, into=c("VC Status", "overlaps"), sep=" ", remove = F)
vc_status_pops <- reshape::melt(table(vc_status_pops$`VC Status`[grep("--", vc_status_pops$Genome)]))
colnames(vc_status_pops) <- c("Status", "Count")
vc_status_pops$binary <- "Not Clustered"
vc_status_pops$binary[vc_status_pops$Status=="Clustered"] <- "Clustered"
```

only keep clustered sequences
```{r}
tax_assigned_clusters <- tax_assigned_clusters[tax_assigned_clusters$`VC Status`=="Clustered",]
```

remove clusters that don't have any of my contigs and that don't have a taxonomy assignment
```{r}
tax_assigned_clusters$`VC Genera`[is.na(tax_assigned_clusters$`VC Genera`)] <- 0
tax_assigned_clusters$`VC Families`[is.na(tax_assigned_clusters$`VC Families`)] <- 0
tax_assigned_clusters$`VC Orders`[is.na(tax_assigned_clusters$`VC Orders`)] <- 0


tax_assigned_clusters <- tax_assigned_clusters[!(tax_assigned_clusters$`VC Genera`==1 & tax_assigned_clusters$`VC Families`==1 & tax_assigned_clusters$`VC Orders`==1),]

```

```{r}
head(tax_assigned_clusters)
```



## Add consensus taxonomy
```{r}
#clusters <- unique(tax_assigned_clusters$unique_vc_subcluster)
clusters <- unique(tax_assigned_clusters$`VC`)
clusters <- clusters[!is.na(clusters)]
```



```{r}
tax_assigned_clusters$Consensus_Genus <- "Unassigned"
tax_assigned_clusters$Consensus_Family <- "Unassigned"
tax_assigned_clusters$Consensus_Order <- "Unassigned"
```

```{r}
head(tax_assigned_clusters, n=100)
```
this gets the taxonomy for a given vcontact2 cluster
```{r}
for (cluster in clusters){
  tax_subset <- tax_assigned_clusters[!is.na(tax_assigned_clusters$`VC`),]
#  tax_subset <- tax_subset[tax_subset$unique_vc_subcluster == cluster,]
  tax_subset <- tax_subset[tax_subset$`VC` == cluster,]
    genus <- unique(tax_subset$Genus[tax_subset$Genus != "Unassigned"])
  order <- unique(tax_subset$Order[tax_subset$Order != "Unassigned"])
  family <- unique(tax_subset$Family[tax_subset$Family != "Unassigned"])
  if (length(genus)==1){
    tax_assigned_clusters$Consensus_Genus[tax_assigned_clusters$`VC` == cluster] <- genus
    if (length(family) != 1) {family="Unassigned"}
    if (length(family) > 1) {family="mixed family"}
    tax_assigned_clusters$Consensus_Family[tax_assigned_clusters$`VC` == cluster] <- family
    if (length(order) != 1) {order="Unassigned"}
    if (length(order) > 1) {order="mixed order"}
    tax_assigned_clusters$Consensus_Order[tax_assigned_clusters$`VC` == cluster] <- order
  } else {
    if (length(genus) > 1) {
      tax_assigned_clusters$Consensus_Genus[tax_assigned_clusters$`VC` == cluster] <- "mixed genus"
    }
    if (length(family)==1){
      tax_assigned_clusters$Consensus_Family[tax_assigned_clusters$`VC` == cluster] <- family
      if (length(order) != 1) {order="Unassigned"}
      if (length(order) > 1) {order="mixed order"}
      tax_assigned_clusters$Consensus_Order[tax_assigned_clusters$`VC` == cluster] <- order
    } else {
      if (length(family) > 1) {
        tax_assigned_clusters$Consensus_Family[tax_assigned_clusters$`VC` == cluster] <- "mixed family"
      }
      if (length(order)==1){
        tax_assigned_clusters$Consensus_Order[tax_assigned_clusters$`VC` == cluster] <- order
      }  
      else {
        if (length(order) > 1) {
          tax_assigned_clusters$Consensus_Order[tax_assigned_clusters$`VC` == cluster] <- "mixed order"
        }
      }
    }
  }
}   
```

## this gets the taxonomy for each VP and then only keeps one contig per VP

```{r}
VP_list <- unique(tax_assigned_clusters$VP_ID)
VP_list <- VP_list[!is.na(VP_list)]
```

```{r}
tax_assigned_clusters$VP_Consensus_Genus <- "Unassigned"
tax_assigned_clusters$VP_Consensus_Family <- "Unassigned"
tax_assigned_clusters$VP_Consensus_Order <- "Unassigned"
```

```{r}
for (VP in VP_list){
  tax_subset <- tax_assigned_clusters[!is.na(tax_assigned_clusters$VP_ID),]
#  tax_subset <- tax_subset[tax_subset$unique_vc_subcluster == cluster,]
  tax_subset <- tax_subset[tax_subset$VP_ID == VP,]
  genus <- unique(tax_subset$Consensus_Genus[tax_subset$Consensus_Genus != "Unassigned"])
  order <- unique(tax_subset$Consensus_Order[tax_subset$Consensus_Order != "Unassigned"])
  family <- unique(tax_subset$Consensus_Family[tax_subset$Consensus_Family != "Unassigned"])
  if (length(genus)==1){
    tax_assigned_clusters$VP_Consensus_Genus[tax_assigned_clusters$VP_ID == VP] <- genus
    if (length(family) != 1) {family="Unassigned"}
    if (length(family) > 1) {family="mixed family"}
    tax_assigned_clusters$VP_Consensus_Family[tax_assigned_clusters$VP_ID == VP] <- family
    if (length(order) != 1) {order="Unassigned"}
    if (length(order) > 1) {order="mixed order"}
    tax_assigned_clusters$VP_Consensus_Order[tax_assigned_clusters$VP_ID == VP] <- order
  } else {
    if (length(genus) > 1) {
      tax_assigned_clusters$VP_Consensus_Genus[tax_assigned_clusters$VP_ID == VP] <- "mixed genus"
    }
    if (length(family)==1){
      tax_assigned_clusters$VP_Consensus_Family[tax_assigned_clusters$VP_ID == VP] <- family
      if (length(order) != 1) {order="Unassigned"}
      if (length(order) > 1) {order="mixed order"}
      tax_assigned_clusters$VP_Consensus_Order[tax_assigned_clusters$VP_ID == VP] <- order
    } else {
      if (length(family) > 1) {
        tax_assigned_clusters$VP_Consensus_Family[tax_assigned_clusters$VP_ID == VP] <- "mixed family"
      }
      if (length(order)==1){
        tax_assigned_clusters$VP_Consensus_Order[tax_assigned_clusters$VP_ID == VP] <- order
      }  
      else {
        if (length(order) > 1) {
          tax_assigned_clusters$VP_Consensus_Order[tax_assigned_clusters$VP_ID == VP] <- "mixed order"
        }
      }
    }
  }
}   
```


### only keep the viral populations
```{r}
tax_assigned_clusters_my_contigs <- tax_assigned_clusters[grep("--", tax_assigned_clusters$Genome),]
tax_assigned_clusters_my_VPs <- tax_assigned_clusters[!duplicated(tax_assigned_clusters$VP_ID),]
```

```{r}
head(tax_assigned_clusters_my_contigs)
```
```{r}
head(tax_assigned_clusters_my_VPs)
```


```{r}
write_tsv(tax_assigned_clusters, "tax_assigned_clusters", col_names = T)
write_tsv(tax_assigned_clusters_my_contigs, "tax_assigned_clusters_my_contigs.txt",col_names = T)
write_tsv(tax_assigned_clusters_my_VPs, "tax_assigned_clusters_my_VPs.txt",col_names = T)
```

```{r}
length(unique(tax_assigned_clusters_my_contigs$`VC`))
length(unique(tax_assigned_clusters_my_VPs$`VC`))

```

```{r}
table(tax_assigned_clusters_my_contigs$Consensus_Genus)
table(tax_assigned_clusters_my_contigs$Consensus_Family)
table(tax_assigned_clusters_my_contigs$Consensus_Order)
```

```{r}
table(tax_assigned_clusters_my_VPs$VP_Consensus_Genus)
table(tax_assigned_clusters_my_VPs$VP_Consensus_Family)
table(tax_assigned_clusters_my_VPs$VP_Consensus_Order)
```

```{r}
clusters <- read_tsv("~/Desktop/erie_story_r_work/merged_3kb_trimmed_viruses_and_ma_virus_references_95-85_clusters_parsed.tsv", col_names=T)
clusters_unique <- clusters[!duplicated(clusters$cluster),]
```

```{r}
tax_assigned_clusters_viral_pops <- tax_assigned_clusters_my_contigs[tax_assigned_clusters_my_contigs$Genome %in% clusters_unique$contig,]
```

```{r}
table(tax_assigned_clusters_viral_pops$Consensus_Genus)
table(tax_assigned_clusters_viral_pops$Consensus_Family)
table(tax_assigned_clusters_viral_pops$Consensus_Order)
```

##for contigs
```{r}
levels(vc_status$Status)[1] <- "Clustered - Not Annotated"
levels(vc_status$Status)[2] <- "Clustered - Singleton"

levels(vc_status$Status) <- c(levels(vc_status$Status), "Clustered - Annotated")
vc_status <- rbind(vc_status, c("Clustered - Annotated", nrow(tax_assigned_clusters_my_contigs), "Clustered"))

vc_status$Count <- as.numeric(vc_status$Count)
vc_status$Count[vc_status$Status=="Clustered - Annotated"] <- vc_status$Count[vc_status$Status=="Clustered - Not Annotated"] - vc_status$Count[vc_status$Status=="Clustered - Annotated"]

vc_status$Status <- relevel(vc_status$Status, "Clustered - Annotated")

levels(vc_status$Status) <- c("Clustered - Annotated", "Clustered - Not Annotated",
                              "Clustered - Singleton", "Outlier", "Overlap", "Singleton")
```


##for vps
```{r}
levels(vc_status_pops$Status)[1] <- "Clustered - Not Annotated"
levels(vc_status_pops$Status)[2] <- "Clustered - Singleton"

levels(vc_status_pops$Status) <- c(levels(vc_status_pops$Status), "Clustered - Annotated")
vc_status_pops <- rbind(vc_status_pops, c("Clustered - Annotated", nrow(tax_assigned_clusters_my_contigs), "Clustered"))

vc_status_pops$Count <- as.numeric(vc_status_pops$Count)
vc_status_pops$Count[vc_status_pops$Status=="Clustered - Annotated"] <- vc_status_pops$Count[vc_status_pops$Status=="Clustered - Not Annotated"] - vc_status_pops$Count[vc_status_pops$Status=="Clustered - Annotated"]

vc_status_pops$Status <- relevel(vc_status_pops$Status, "Clustered - Annotated")

levels(vc_status_pops$Status) <- c("Clustered - Annotated", "Clustered - Not Annotated",
                              "Clustered - Singleton", "Outlier", "Overlap", "Singleton")
```




```{r}
p2 <- ggplot(vc_status, aes(x=binary, y=Count, 
                   color=Status, fill=Status)) +
  geom_col() +
  coord_flip() +
  theme(panel.background = element_blank(), 
        axis.line = element_line(colour = "black"), 
        panel.border = element_rect(colour = "black", fill=NA, size=1), 
        axis.title=element_text(size=12), 
        axis.text.y = element_text(size=12, colour = "black"),
        axis.text.x  = element_text(size=8, angle=0, vjust=1, hjust=0.5, colour="black"),
        plot.margin = unit(c(0.5, 1, 5, 0.6),"lines"),
        #legend.position = "bottom", 
        legend.direction = "horizontal",
        legend.text = element_text(size=8),
        legend.position = c(0.2,-1.7)) +
  guides(fill=guide_legend(nrow=3, byrow=T), color=guide_legend(nrow=3, byrow=T)) +
  scale_colour_manual(name = '',
                     values = alpha(c("black", plasma(8)[7:2]), 1)) +
  scale_fill_manual(name = '',
                     values = alpha(c("black", plasma(8)[7:2]), 0.2)) +
  xlab("") +
  ylab("Number of Viral Contigs") 
p2
```

```{r}
png(filename="clusters.png", width=4, height=2, units = "in", res=300)
p2
dev.off()
```

### Flow diagram to visualize taxonomy
```{r}
library(networkD3)
library(reshape)
```



```{r}
tax_assigned_clusters_my_contigs_subset <- tax_assigned_clusters_my_contigs[tax_assigned_clusters_my_contigs$Consensus_Family!="Unassigned",]
links1 <- melt(table(tax_assigned_clusters_my_contigs_subset$Consensus_Order,
                     tax_assigned_clusters_my_contigs_subset$Consensus_Family))
colnames(links1) <- c("order", "family", "count")
links1 <- links1[links1$count!=0,]
links1 <- links1[order(links1$order),]
levels(links1$order)[length(levels(links1$order))] <- "Unassigned order"
links1
```

```{r}
links2 <-melt(table(tax_assigned_clusters_my_contigs_subset$Consensus_Family,
                     tax_assigned_clusters_my_contigs_subset$Consensus_Genus))
colnames(links2) <- c("family", "genus", "count")
links2 <- links2[links2$count!=0,]
levels(links2$genus)[levels(links2$genus)=="Unassigned"] <- "Unassigned genus"
links2
```

```{r}
# A connection data frame is a list of flows with intensity for each flow
links <- data.frame()


links <- data.frame(
  source=c(as.character(links1$order), as.character(links2$family)),
  target=c(as.character(links1$family), as.character(links2$genus)),
  value=c(links1$count, links2$count)
)
 
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
  name=c(as.character(links$source), 
  as.character(links$target)) %>% unique()
)
 
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1
 
#nodes$group <- as.factor(c("a","a","a","b","b","a","b"))

#links$group <- as.factor(c("type_b","type_a","type_a","type_b","type_a","type_b"))

# prepare color scale: I give one specific color for each node.
#my_color <- 'd3.scaleOrdinal() .domain(["type_a", "type_b", "a", "b"]) .range(["#B63679FF", "#FB8861FF", "#B63679FF", "#FB8861FF"])'
 
p <- sankeyNetwork(Links = links, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE,
              fontSize = 18)

# Make the Network. I call my colour scale with the colourScale argument
#p <- sankeyNetwork(Links = links, Nodes = nodes, Source = "IDsource", Target = "IDtarget", 
#              Value = "value", NodeID = "name", 
#              colourScale=my_color, LinkGroup="group", NodeGroup="group",
#              fontSize = 26)
p

library(htmlwidgets)
saveWidget(p, file="sankey_taxonomy_contigs.html")
```

### Flow diagram to visualize taxonomy
```{r}
library(networkD3)
library(reshape)
```



```{r}
tax_assigned_clusters_my_VPs_subset <- tax_assigned_clusters_my_VPs[tax_assigned_clusters_my_VPs$VP_Consensus_Family!="Unassigned",]
links1 <- melt(table(tax_assigned_clusters_my_VPs_subset$VP_Consensus_Order,
                     tax_assigned_clusters_my_VPs_subset$VP_Consensus_Family))
colnames(links1) <- c("order", "family", "count")
links1 <- links1[links1$count!=0,]
links1 <- links1[order(links1$order),]
#levels(links1$order)[2] <- "unassigned order"
#levels(links1$family)[length(levels(links1$family))] <- "unassigned family"
levels(links1$order)[length(levels(links1$order))] <- "Unassigned order"
links1
```

```{r}
links2 <-melt(table(tax_assigned_clusters_my_VPs_subset$VP_Consensus_Family,
                     tax_assigned_clusters_my_VPs_subset$VP_Consensus_Genus))
colnames(links2) <- c("family", "genus", "count")
links2 <- links2[links2$count!=0,]
#levels(links2$family)[length(levels(links2$family))] <- "unassigned family"
levels(links2$genus)[levels(links2$genus)=="Unassigned"] <- "unassigned genus"
links2
```

```{r}
# A connection data frame is a list of flows with intensity for each flow
links <- data.frame()


links <- data.frame(
  source=c(as.character(links1$order), as.character(links2$family)),
  target=c(as.character(links1$family), as.character(links2$genus)),
  value=c(links1$count, links2$count)
)
 
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
  name=c(as.character(links$source), 
  as.character(links$target)) %>% unique()
)
 
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1
 
#nodes$group <- as.factor(c("a","a","a","b","b","a","b"))

#links$group <- as.factor(c("type_b","type_a","type_a","type_b","type_a","type_b"))

# prepare color scale: I give one specific color for each node.
#my_color <- 'd3.scaleOrdinal() .domain(["type_a", "type_b", "a", "b"]) .range(["#B63679FF", "#FB8861FF", "#B63679FF", "#FB8861FF"])'
 
p <- sankeyNetwork(Links = links, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE,
              fontSize = 18)

# Make the Network. I call my colour scale with the colourScale argument
#p <- sankeyNetwork(Links = links, Nodes = nodes, Source = "IDsource", Target = "IDtarget", 
#              Value = "value", NodeID = "name", 
#              colourScale=my_color, LinkGroup="group", NodeGroup="group",
#              fontSize = 26)
p

library(htmlwidgets)
saveWidget(p, file="sankey_taxonomy.html")
```


#######################################################
# For Cytoscape


## make a smaller version of the network file that only includes pairs with my contigs
### This is for the VPs
```{r}
network_connections <- read_delim("~/Desktop/erie_story_r_work/c1_updated.ntw", delim = " ", col_names = F)
colnames(network_connections) <- c("Partner_One", "Partner_Two", "Weight")
network_connections$Partner_One <- sub(".*_3000_viralonly_", "", network_connections$Partner_One)
network_connections$Partner_Two <- sub(".*_3000_viralonly_", "", network_connections$Partner_Two)
```

```{r}
network_connections$In_One <- 0
network_connections$In_One[grep("--", network_connections$Partner_One)] <- 1

network_connections$In_Two <- 0
network_connections$In_Two[grep("--", network_connections$Partner_Two)] <- 1

network_connections$Keep <- network_connections$In_One + network_connections$In_Two
```

only keep genomes that are mine or connect with one of my contigs
```{r}
network_connections_subset <- network_connections[network_connections$Keep>0,]
```

remove any that are duplicates
```{r}
network_connections_subset$Both_Partners <- paste(network_connections_subset$Partner_One,
                                                  network_connections_subset$Partner_Two,
                                                  sep = "--")
network_connections_subset <- network_connections_subset[!duplicated(network_connections_subset$Both_Partners),]
```


### add color attribute
# this is now for viral population's taxonomy, but you would have to subset it to not have all of the contigs)

```{r}
tax_assigned_clusters <- read_tsv("tax_assigned_clusters")
```


```{r}
network_connections_subset <- left_join(network_connections_subset, tax_assigned_clusters, by=c("Partner_One"="Genome")) 
#network_connections_subset <- network_connections_subset[,-c(4:6,11,13:23)]
#colnames(network_connections_subset)[c((ncol(network_connections_subset)-2):ncol(network_connections_subset))] <-
#  c("Consensus_Genus_Partner_One", "Consenus_Family_Partner_One", "Consensus_Order_Partner_One")
```

```{r}
head(network_connections_subset)
```


###add color
```{r}
network_connections_subset$consensus_source_color <- "black"
network_connections_subset$consensus_source_color[network_connections_subset$Consensus_Family=="Microviridae"] <- "red"
network_connections_subset$consensus_source_color[network_connections_subset$Consensus_Family=="mixed family"] <- "brown"
network_connections_subset$consensus_source_color[network_connections_subset$Consensus_Family=="Myoviridae"] <- "blue"
network_connections_subset$consensus_source_color[network_connections_subset$Consensus_Family=="Podoviridae"] <- "orange"
network_connections_subset$consensus_source_color[network_connections_subset$Consensus_Family=="Siphoviridae"] <- "green"
```

###add shape
```{r}
network_connections_subset$consensus_source_shape <- "diamond"
network_connections_subset$consensus_source_shape[network_connections_subset$Consensus_Family=="Microviridae"] <- "ellipse"
network_connections_subset$consensus_source_shape[network_connections_subset$Consensus_Family=="mixed family"] <- "ellipse"
network_connections_subset$consensus_source_shape[network_connections_subset$Consensus_Family=="Myoviridae"] <- "ellipse"
network_connections_subset$consensus_source_shape[network_connections_subset$Consensus_Family=="Podoviridae"] <- "ellipse"
network_connections_subset$consensus_source_shape[network_connections_subset$Consensus_Family=="Siphoviridae"] <- "ellipse"
```


###add node size at the family level
```{r}
merged_network_connections_high_freq$source_size <- "50"

merged_network_connections_high_freq$source_size[merged_network_connections_high_freq$Family=="Microviridae"] <- "50"
merged_network_connections_high_freq$source_size[merged_network_connections_high_freq$Family=="Myoviridae"] <- "50"
merged_network_connections_high_freq$source_size[merged_network_connections_high_freq$Family=="Podoviridae"] <- "50"
merged_network_connections_high_freq$source_size[merged_network_connections_high_freq$Family=="Siphoviridae"] <- "50"
```

```{r}
write_tsv(network_connections_subset, file="c1_all_contigs_ajw_7_20_22.ntw", col_names = T)
```

```{r}
#network_connections_subset <- read_tsv("../PaperDrafts/CodeForPaper/c1_all_contigs.ntw", col_names = T)
```

```{r}
head(network_connections_subset)
```


## Reducing the number of contigs in the network graph

## import rpkm normalized read counts
```{r}
merged_tpm <- read_tsv("~/Desktop/erie_story_r_work/abund_table_tpm_normalized_clusters_with_metadata.tsv")
```

## create abundance table for diversity analyses
```{r}
abund_table <- merged_tpm[,-c((ncol(merged_tpm)-25):ncol(merged_tpm))]

abund_table_rel <-abund_table/rowSums(abund_table)*100
hist(log10(colSums(abund_table_rel)))
table(colSums(abund_table_rel)>1)

abund_table <- abund_table[,colSums(abund_table_rel)>1]
abund_table_rel <- abund_table_rel[,colnames(abund_table_rel) %in% colnames(abund_table)]

abund_table_pres <- apply(abund_table, c(1,2), function(x) if (x>0) {x=1} else {x=0})

abund_table_order <- abund_table_pres
abund_table_order[,] <- 0

for (i in 1:nrow(abund_table)) {
  ranking <- tibble(order=order(abund_table[i,], decreasing=T),
                    placement=seq(1:ncol(abund_table)))
  for (j in 1:ncol(abund_table)) {
    if (abund_table_pres[i,j]==1)
      abund_table_order[i,j] <- ranking$placement[ranking$order==j]  
  }
}

abund_table_order_bin <- matrix(nrow=nrow(abund_table),
                            ncol=ncol(abund_table), data = 0)

for (i in 1:nrow(abund_table)) {
  num_clusters <- sum(abund_table_pres[i,])
  for (j in 1: ncol(abund_table)) {
    if (abund_table_order[i,j]<=(num_clusters*.1) & abund_table_order[i,j]!=0) 
      abund_table_order_bin[i,j] <- 1
  }
}

table(abund_table_rel>10)
abund_table_order_bin_1percent <- matrix(nrow=nrow(abund_table),
                            ncol=ncol(abund_table), data = 0)

for (i in 1:nrow(abund_table)) {
  for (j in 1: ncol(abund_table)) {
    if (abund_table_rel[i,j]>=1 & abund_table_order[i,j]!=0) 
      abund_table_order_bin_1percent[i,j] <- 1
  }
}

abund_table_order_bin_halfpercent <- matrix(nrow=nrow(abund_table),
                            ncol=ncol(abund_table), data = 0)

for (i in 1:nrow(abund_table)) {
  for (j in 1: ncol(abund_table)) {
    if (abund_table_rel[i,j]>=0.5 & abund_table_order[i,j]!=0) 
      abund_table_order_bin_halfpercent[i,j] <- 1
  }
}

num_samples_contig_in <- tibble(VP_ID=colnames(abund_table_pres),
                                samples_present_in=colSums(abund_table_pres),
                                read_abundance=colSums(abund_table),
                                rank=colSums(abund_table_order_bin),
                                rank1percent=colSums(abund_table_order_bin_1percent),
                                rankhalfpercent=colSums(abund_table_order_bin_halfpercent))

num_samples_contig_in <- num_samples_contig_in[-c(440,593),]

write_tsv(num_samples_contig_in, "~/Desktop/erie_story_r_work/num_samples_contig_in.tsv", col_names = TRUE)
```



```{r}
pal <- ggthemes::tableau_color_pal(palette="Tableau 10", type="regular")
num_samples_contig_in$color <- pal(2)[1]
num_samples_contig_in$color[num_samples_contig_in$samples_present_in>=16] <- pal(2)[2]
```



looking at the taxonomy of these abundant clusters
```{r}
tax_assigned_clusters_my_VPs <- read_tsv("tax_assigned_clusters_my_VPs.txt")
```


for contig based visualization
```{r}
#num_samples_contig_in_subset <- num_samples_contig_in[num_samples_contig_in$rank1percent>1,] %>% 
#  left_join(VPs, by="cluster") %>%
#  left_join(tax_assigned_clusters_my_contigs,
#            by=c("cluster", "contig"="Genome"))
```

no abundance threshold
```{r}
num_samples_contig_in_subset <- num_samples_contig_in %>% 
  left_join(tax_assigned_clusters_my_VPs,
            by=c("VP_ID"))
```

1 percent abundance threshold
```{r}
num_samples_contig_in_subset <- num_samples_contig_in[num_samples_contig_in$rank1percent>=1,] %>% 
  left_join(tax_assigned_clusters_my_VPs,
            by=c("VP_ID"))
```


```{r}
clusters <- unique(num_samples_contig_in_subset$VP_ID)
clusters <- clusters[!is.na(clusters)]
```



```{r}

p4 <- ggplot(num_samples_contig_in_subset, aes(x=samples_present_in,
                                            y=rank)) + 
  geom_point(shape=21, fill="grey", color="black", alpha=0.5, size=3) +
  theme(panel.background = element_blank(), 
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, size=1),
        axis.text=element_text(size=8, colour="black"),
        axis.title=element_text(size=10),
        legend.key=element_blank(),
        legend.position = "none", 
        plot.margin = unit(c(0.2, 0.2, 2, 0.6),"lines"),
        legend.direction = "horizontal",
        legend.text = element_text(size=8),
        legend.title = element_text(size=10),
        legend.background = element_blank()) +
  xlab("Number of Samples Present In") + ylab("Number of Samples where Abundant") 
  #scale_y_log10()

p4

```





```{r}
png(filename="~/Desktop/erie_story_r_work/one_percent_samples_abundant_vs_samples_present_aug_17_22.png", width=5, height=4, units = "in", res=300)
p4
dev.off()
```
```{r}
pdf("~/Desktop/erie_story_r_work/one_percent_samples_abundant_vs_samples_present_aug_17_22.pdf", width=9, height=6)
p4
dev.off()
```


### consider a sample "high frequency" if it is found in at least x samples

this was already only including VPs
```{r}
high_freq_contig <- num_samples_contig_in$VP_ID[num_samples_contig_in$samples_present_in>=(nrow(abund_table)/36)]
#high_freq_contig <- clusters[clusters$cluster %in% high_freq_contig,]
#clusters_unique <- clusters[!duplicated(clusters$cluster),]
high_freq_contig <- clusters[clusters %in% high_freq_contig]

network_connections_high_freq <- separate(network_connections_subset, `VC_subcluster_VP_combo`, into=c("partner_one_VC", "partner_one_VP"), sep="--", remove = F)

table(network_connections_high_freq$partner_one_VP %in% high_freq_contig)


network_connections_high_freq$In_One <- 0
network_connections_high_freq$In_One[network_connections_high_freq$partner_one_VP %in% high_freq_contig] <- 1

network_connections_high_freq$In_Two <- 0
network_connections_high_freq$In_Two[network_connections_high_freq$Partner_Two %in% high_freq_contig] <- 1

network_connections_high_freq$In_One[!grepl("--", network_connections_high_freq$Partner_One)] <- 0.5

network_connections_high_freq$In_Two[!grepl("--", network_connections_high_freq$Partner_Two)] <- 0.5

network_connections_high_freq$Keep <- network_connections_high_freq$In_One + network_connections_high_freq$In_Two

network_connections_high_freq <- network_connections_high_freq[network_connections_high_freq$Keep>=1,]


```

remove genomes not in VCs
```{r}
network_connections_high_freq <- network_connections_high_freq[!(is.na(network_connections_high_freq$`VC Status`)),]
```

```{r}
network_connections_high_freq_swap <- network_connections_high_freq 
network_connections_high_freq_swap$Partner_One <- network_connections_high_freq$Partner_Two
network_connections_high_freq_swap$Partner_Two <- network_connections_high_freq$Partner_One


  
merged_network_connections_high_freq <- left_join(network_connections_high_freq_swap, tax_assigned_clusters, by=c("Partner_One"="Genome"), na_matches="never") 

```


add color at the family level only for the reference genomes
```{r}
merged_network_connections_high_freq$source_color <- "black"

merged_network_connections_high_freq$source_color[merged_network_connections_high_freq$Family.y=="Microviridae"] <- "red"
merged_network_connections_high_freq$source_color[merged_network_connections_high_freq$Family.y=="Myoviridae"] <- "blue"
merged_network_connections_high_freq$source_color[merged_network_connections_high_freq$Family.y=="Podoviridae"] <- "orange"
merged_network_connections_high_freq$source_color[merged_network_connections_high_freq$Family.y=="Siphoviridae"] <- "green"
```

add shape to our nodes at the family level to differentiate from own viral contigs
```{r}
merged_network_connections_high_freq$source_shape <- "diamond"

merged_network_connections_high_freq$source_shape[merged_network_connections_high_freq$Family.y=="Microviridae"] <- "ellipse"
merged_network_connections_high_freq$source_shape[merged_network_connections_high_freq$Family.y=="Myoviridae"] <- "ellipse"
merged_network_connections_high_freq$source_shape[merged_network_connections_high_freq$Family.y=="Podoviridae"] <- "ellipse"
merged_network_connections_high_freq$source_shape[merged_network_connections_high_freq$Family.y=="Siphoviridae"] <- "ellipse"
```


add node size at the family level
```{r}
merged_network_connections_high_freq$source_size <- "20"

merged_network_connections_high_freq$source_size[merged_network_connections_high_freq$Family.y=="Microviridae"] <- "20"
merged_network_connections_high_freq$source_size[merged_network_connections_high_freq$Family.y=="Myoviridae"] <- "20"
merged_network_connections_high_freq$source_size[merged_network_connections_high_freq$Family.y=="Podoviridae"] <- "20"
merged_network_connections_high_freq$source_size[merged_network_connections_high_freq$Family.y=="Siphoviridae"] <- "20"
```


```{r}
merged_network_connections_high_freq_my_VPs_linked_to_refs <- merged_network_connections_high_freq[merged_network_connections_high_freq$'source_color'!="black",]

```


```{r}
write_tsv(merged_network_connections_high_freq_my_VPs_linked_to_refs, file="c1_high_freq_viral_pops_with_refs_only_in_1_or_more_samples_no_threshold_updated_7_20_22_ajw.ntw", col_names = T)
```




